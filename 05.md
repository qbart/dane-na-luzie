# SQL w praktyce

## Najważniejsze konstrukcje SQL

- **SELECT** - projekcja danych (służy do określenia, co chcemy wyświetlić)
- **FROM** - źródło danych (określa główną tabelę)
- **JOIN** - łączenie informacji (umożliwia budowanie kontekstu z kilku tabel)
- **WHERE** - filtrowanie (zawężenia wyników)
- **GROUP BY + agregacje** - podsumowanie danych (pozwala na odpowiedzi typu "ile / które / w jakiej liczbie".)
- **ORDER BY** - sortowanie wyników (dla rankingów, list, analiz)
- **LIMIT / OFFSET** - ograniczanie wyników

## Podstawowe operacje

- SELECT
- INSERT
- UPDATE
- DELETE

```sql
-- pobranie 10 kursow posortowanych po nazwie
SELECT * FROM course ORDER BY name LIMIT 10;
```

```sql
-- pobranie lekcji z kursu o ID = 1
SELECT * FROM lesson WHERE course_id = 1;
```

```sql
-- dodanie kursu
INSERT INTO course (name, description)
  VALUES ('Yoga', 'Praktyka łącząca świadomy oddech z łagodnym ruchem');
```

```sql
-- aktualizacja ceny 199 i waluty dla kursu o ID = 1
UPDATE course SET price = 199.0, currency = 'PLN' WHERE id = 1;
```

```sql
-- usuniecie kursu o id = 1
DELETE FROM course WHERE id = 1;
```

## Ograniczenia

Każda tabela powinna mieć **przynajmniej 1 klucz główny** (`PRIMARY KEY`), które jednoznacznie identfikuje obiekt w tabeli.
Może to być wartość tworzona przez system, która nie ma znacznie biznesowego (tzw. surrogate key) lub klucz naturlany.

Przykłady identyfikatorów bez znaczenia biznesowego:
- 1, 2, 3, ...
- 7eaad914-971e-4973-92c7-047c606ea3f9, f2a06af8-c7a0-4211-8609-e4761e531990

Przykłady kluczy naturalnych:
- kody krajów: PL, DE, 
- PESEL
- ...

> [!TIP]
> Mimo kluczy naturalnych często używa się identyfikatorów nie mających znaczenia biznesowego.

## Dokumentacja

https://www.postgresql.org/docs/16/sql-select.html

## Chwila zabawy ✏️

1. Zaloguj się do pgAdmina
2. Stwórz swoją bazę danych.

```sql
-- zamien X na swoj numer usera
CREATE DATABASE lmsX;
```

3. Stwórz nowę połączenie na bazie danych (do bazy lmsX zamiast workshop).
4. Pracuj już na nowym połączeniu.
5. Stwórz podstawową strukturę:

```sql
CREATE TABLE student (
    id    BIGSERIAL PRIMARY KEY,
    name  TEXT      NOT NULL
)

CREATE TABLE course (
    id   SERIAL PRIMARY KEY,
    name TEXT   NOT NULL
);

CREATE TABLE lesson (
    id        SERIAL  PRIMARY KEY,
    course_id INTEGER NOT NULL REFERENCES course(id),
    name      TEXT    NOT NULL
);

CREATE TABLE enrollment (
    id          SERIAL      PRIMARY KEY,
    student_id  INTEGER     NOT NULL REFERENCES student(id),
    course_id   INTEGER     NOT NULL REFERENCES course(id),
    enrolled_at TIMESTAMPTZ DEFAULT now()
);
```

6. Dodaj przykładowe dane do tabel:

```sql
INSERT INTO student (name) VALUES
  ('Anita'),
  ('Ewa'),
  ('Karolina'),
  ('Kasia');

INSERT INTO course (name) VALUES
  ('Yoga Flow'),
  ('Squash Basics'),
  ('Volleyball Essentials');

INSERT INTO lesson (course_id, name) VALUES
-- Yoga
(1, 'Breath & Balance'),
(1, 'Sun Salutation Sequence'),

-- Squash
(2, 'Grip & Footwork'),
(2, 'Serving Technique'),

-- Volleyball
(3, 'Setting Fundamentals'),
(3, 'Team Positioning');

INSERT INTO enrollment (student_id, course_id) VALUES
-- Yoga
(1, 1),
(2, 1),
(3, 1),

-- Squash
(4, 2);
```

7. Przetestuj różne opcje SELECT / OFFSET / LIMIT / ORDER BY

## Łączenie tabel

Najczęściej będą nam potrzebne dwa typy JOINów: 

### INNER JOIN

![join](./img_inner_join.png)

### LEFT JOIN

![left](./img_left_join.png)


### Ćwiczenia


#### JOINy

Uruchom oba zapytania i przeanalizuj różnicę:

```sql
select * from course c
inner join enrollment e on e.course_id = c.id
```


```sql
select * from course c
left join enrollment e on e.course_id = c.id
```

> [!TIP]
> Dodaliśmy tutaj też aliasowanie tabel, w prostych zapytaniach nie jest potrzebne, ale przy skomplikowanych zapytaniach
> bardzo przydatne lub niemożliwe do pominięcia. Alternatywnie można użyć słowa kluczowego `AS` między tabelą a aliasem:
> np.:
> ```sql
> select * from course AS c
> ```

Dlaczego joiny są tak istotne? Wyobraź sobie, że chcesz wyświetliść na stronie kursy z ilością uczestników:


```sql
select
    c.id,
    c.name,
    count(e.*) as total
from course c
join enrollment e on e.course_id = c.id
group by c.id
order by total desc
```


```sql
select
    c.id,
    c.name,
    count(e.*) as total
from course c
left join enrollment e on e.course_id = c.id
group by c.id
order by total desc
```

Moment na dyskusję o tym co zobaczyliśmy.

#### Zadania

1. Wyswietl listę, która pokazuje:
- id i nazwę kursu,
- imię uczestnika oraz kiedy dana osoba dołączyła

<details>
<summary>Wskazówka</summary>
JOINów można używać wiecej niż raz w danym zapytaniu.
</details>

<details>
<summary>Pełna odpowiedź</summary>

```sql
select 
    c.id,
    c.name,
    s.name AS student_name,
    e.enrolled_at
from course c
join enrollment e on e.course_id = c.id
join student s on s.id = e.student_id
```

</details>

2. 

