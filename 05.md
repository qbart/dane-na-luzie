# SQL w praktyce (16:15 - 17:00)

## Najważniejsze konstrukcje SQL

- **SELECT** - projekcja danych (służy do określenia, co chcemy wyświetlić)
- **FROM** - źródło danych (określa główną tabelę)
- **JOIN** - łączenie informacji (umożliwia budowanie kontekstu z kilku tabel)
- **WHERE** - filtrowanie (zawężenia wyników)
- **GROUP BY + agregacje** - podsumowanie danych (pozwala na odpowiedzi typu "ile / które / w jakiej liczbie".)
- **ORDER BY** - sortowanie wyników (dla rankingów, list, analiz)
- **LIMIT / OFFSET** - ograniczanie wyników

### Anatomia zapytania (uproszczona)

```sql
SELECT jakie_kolumny FROM jaka_tabela
JOIN kolejna_tabela ON warunek_laczenia_tabel
WHERE warunek_filtrowania
ORDER BY kryteria_sortowania
LIMIT limit_wierszy OFFSET przesuniecie_wierszy
```

lub wersja z grupowaniem:

```sql
SELECT funkcja_agregujaca(jaka_kolumna), ... FROM jaka_tabela
JOIN kolejna_tabela ON warunek_laczenia_tabel
GROUP BY kryteria_grupowania
```

Nie wszystko jest wymagane.

## Podstawowe operacje

- SELECT
- INSERT
- UPDATE
- DELETE

```sql
-- pobranie 10 kursow posortowanych po nazwie
SELECT * FROM course ORDER BY name LIMIT 10;
```

```sql
-- pobranie lekcji z kursu o ID = 1
SELECT * FROM lesson WHERE course_id = 1;
```

```sql
-- dodanie kursu
INSERT INTO course (name, description)
  VALUES ('Yoga', 'Praktyka łącząca świadomy oddech z łagodnym ruchem');
```

```sql
-- aktualizacja ceny 199 i waluty dla kursu o ID = 1
UPDATE course SET price = 199.0, currency = 'PLN' WHERE id = 1;
```

```sql
-- usuniecie kursu o id = 1
DELETE FROM course WHERE id = 1;
```

## Ograniczenia

Każda tabela powinna mieć **przynajmniej 1 klucz główny** (`PRIMARY KEY`), które jednoznacznie identfikuje obiekt w tabeli.
Może to być wartość tworzona przez system, która nie ma znacznie biznesowego (tzw. surrogate key) lub klucz naturlany.

Przykłady identyfikatorów bez znaczenia biznesowego:
- 1, 2, 3, ...
- 7eaad914-971e-4973-92c7-047c606ea3f9, f2a06af8-c7a0-4211-8609-e4761e531990

Przykłady kluczy naturalnych:
- kody krajów: PL, DE, 
- PESEL
- ...

> [!TIP]
> Mimo kluczy naturalnych często używa się identyfikatorów nie mających znaczenia biznesowego.

## Dokumentacja

https://www.postgresql.org/docs/16/sql-select.html

## Chwila zabawy ✏️

1. Zaloguj się do pgAdmina
2. Stwórz swoją bazę danych.

```sql
-- zamien X na swoj numer usera
CREATE DATABASE lmsX;
```

3. Stwórz nowę połączenie na bazie danych (do bazy lmsX zamiast workshop).
4. Pracuj już na nowym połączeniu.
5. Stwórz podstawową strukturę:

```sql
CREATE TABLE student (
    id    BIGSERIAL PRIMARY KEY,
    name  TEXT      NOT NULL
)

CREATE TABLE course (
    id   SERIAL PRIMARY KEY,
    name TEXT   NOT NULL
);

CREATE TABLE lesson (
    id        SERIAL  PRIMARY KEY,
    course_id INTEGER NOT NULL REFERENCES course(id),
    name      TEXT    NOT NULL
);

CREATE TABLE enrollment (
    id          SERIAL      PRIMARY KEY,
    student_id  INTEGER     NOT NULL REFERENCES student(id),
    course_id   INTEGER     NOT NULL REFERENCES course(id),
    enrolled_at TIMESTAMPTZ DEFAULT now()
);
```

6. Dodaj przykładowe dane do tabel:

```sql
INSERT INTO student (name) VALUES
  ('Anita'),
  ('Ewa'),
  ('Karolina'),
  ('Kasia');

INSERT INTO course (name) VALUES
  ('Yoga Flow'),
  ('Squash Basics'),
  ('Volleyball Essentials');

INSERT INTO lesson (course_id, name) VALUES
-- Yoga
(1, 'Breath & Balance'),
(1, 'Sun Salutation Sequence'),

-- Squash
(2, 'Grip & Footwork'),
(2, 'Serving Technique'),

-- Volleyball
(3, 'Setting Fundamentals'),
(3, 'Team Positioning');

INSERT INTO enrollment (student_id, course_id) VALUES
-- Yoga
(1, 1),
(2, 1),
(3, 1),

-- Squash
(4, 2);
```

7. Przetestuj różne opcje SELECT / OFFSET / LIMIT / ORDER BY

## Łączenie tabel

Najczęściej będą nam potrzebne dwa typy JOINów: 

### INNER JOIN

![join](./img_inner_join.png)

### LEFT JOIN

![left](./img_left_join.png)


### Ćwiczenia


#### JOINy

https://www.postgresql.org/docs/16/queries-table-expressions.html

```sql
TABELA1 typ_joina TABELA2 [ warunek ]
```

Uruchom oba zapytania i przeanalizuj różnicę:

```sql
select * from course c
inner join enrollment e on e.course_id = c.id
```


```sql
select * from course c
left join enrollment e on e.course_id = c.id
```

> [!TIP]
> Dodaliśmy tutaj też aliasowanie tabel, w prostych zapytaniach nie jest potrzebne, ale przy skomplikowanych zapytaniach
> bardzo przydatne lub niemożliwe do pominięcia. Alternatywnie można użyć słowa kluczowego `AS` między tabelą a aliasem:
> np.:
> ```sql
> select * from course AS c
> ```

Dlaczego joiny są tak istotne? Wyobraź sobie, że chcesz wyświetliść na stronie kursy z ilością uczestników:


```sql
select
    c.id,
    c.name,
    count(e.*) as total
from course c
join enrollment e on e.course_id = c.id
group by c.id
order by total desc
```


```sql
select
    c.id,
    c.name,
    count(e.*) as total
from course c
left join enrollment e on e.course_id = c.id
group by c.id
order by total desc
```

Moment na dyskusję o tym co zobaczyliśmy.

### WHERE

Operacje logiczne (`AND`, `OR`, `NOT`):
https://www.postgresql.org/docs/current/functions-logical.html

Porównania (`>`, `<`, `>=`, `<=`, `=`, `!=`):
https://www.postgresql.org/docs/current/functions-comparison.html

<table>
    <tr>
        <td>Operator</td>
        <td>Warunek</td>
        <td>Przykład w SQL</td>
    </tr>
    <tr>
        <td>
            =, !=, &lt;, &lt;=, &gt;, &gt;=
        </td>
        <td>Podstawowe operacje porównania</td>
        <td>wzrost != 170</td>
    </tr>
    <tr>
        <td>
            BETWEEN … AND … 	
        </td>
        <td>Zawiera się pomiędzy (inclusive)</td>
        <td>BETWEEN 160 AND 180</td>
    </tr>
    <tr>
        <td>
            IN (…)
        </td>
        <td>Zawiera się w liście</td>
        <td>wzrost IN (169, 170, 171)</td>
    </tr>
    <tr>
        <td>
            LIKE
        </td>
        <td>Porównanie tekstu (case-sensitive)</td>
        <td>student.name LIKE 'Ka%'</td>
    </tr>
</table>


**Operatory są zależne od typów danych!**

Funkcje:
https://www.postgresql.org/docs/current/functions-math.html

Operacje na tekście:
https://www.postgresql.org/docs/current/functions-string.html

Poniżej fragmenty różnych zapytań z warunkami (filtrowanie danych):

```sql
... WHERE wzrost >= 170    
... WHERE wzrost >= 170 AND wzrost <= 180
... WHERE (wzrost >= 170) AND (wzrost <= 180)
... WHERE (wzrost >= 170 AND wzrost <= 180)
... WHERE wzrost BETWEEN 170 AND 180
... WHERE wzrost BETWEEN 170 AND 180 AND wiek = 30
... WHERE (wzrost BETWEEN 170 AND 180) AND (wiek = 30)
... WHERE NOT(wzrost >= 170)
... WHERE wzrost < 170
... WHERE wzrost > 170 AND wzrost < 180 OR wiek = 30
... WHERE (wzrost > 170 AND wzrost < 180) OR wiek = 30
... WHERE wzrost > 170 AND (wzrost < 180 OR wiek = 30)
... WHERE imie = 'Ewa' OR imie = 'Kasia'
... WHERE imie IN ('Ewa', 'Kasia')
... WHERE imie NOT IN ('Ewa', 'Kasia')
... WHERE imie LIKE 'K%' AND (wzrost >= 150 AND wzrost <= 170) AND wiek NOT IN (20, 21, 22, 23)
... ...
```

Wartości puste tzw. `NULL`:

Jeśli wartość w tabeli nie ma określonej wartości przyjmuje ona wartość `NULL`.
NULL w bazach danych to specjalna wartość i ma specjalne zachowanie np. w agregacjach jest pomijany,
w porównaniach z innymi wartościami zawsze zwraca NULL dlatego istnieją odpowiednie operatory porównania:

```sql
... WHERE enrollment.id IS NULL
... WHERE enrollment.id IS NOT NULL
```

#### Praca własna

Jak podejść do pisania zapytań? Zacznij prosto, od tego co wiesz, a potem doklejaj kolejne elementy.
Jak nie wychodzi to testuj różne opcje!

Ogólnie AI bardzo dobrze radzi sobie z pisaniem SQL,
ale tutaj chcemy najpierw zrozumieć sens działania, a dopiero w przyszłości możemy się wyręczać,
bo będą sytuacje gdzie AI sie pomyli lub nasze pytanie nie będzie precyzyjne,
dlatego ważne są fundamenty, żeby potrafić zweryfikować to co wypluje AI.

1. Policz, ile lekcji zawiera każdy kurs

<details>
<summary>Wskazówka</summary>
GROUP BY i COUNT
</details>

<details>
<summary>Pełna odpowiedź</summary>

```sql
select 
    c.id,
    c.name,
    count(l.*) as lessons
from course c
left join lesson l on l.course_id = c.id
group by c.id
```

</details>

2. Wyswietl listę, która pokazuje:
- id i nazwę kursu,
- imię uczestnika oraz kiedy dana osoba dołączyła

<details>
<summary>Wskazówka</summary>
JOINów można używać wiecej niż raz w danym zapytaniu.
</details>

<details>
<summary>Pełna odpowiedź</summary>

```sql
select 
    c.id,
    c.name,
    s.name AS student_name,
    e.enrolled_at
from course c
join enrollment e on e.course_id = c.id
join student s on s.id = e.student_id
```

</details>

3. Wyświetl kursy bez żadnych uczestników

<details>
<summary>Wskazówka</summary>
Przydatne tutaj gdzieś będzie porówanie z NULLem.
</details>


<details>
<summary>Pełna odpowiedź</summary>

```sql
select c.id, c.name
from course c
left join enrollment e on e.course_id = c.id
where e.id IS NULL
```

</details>

